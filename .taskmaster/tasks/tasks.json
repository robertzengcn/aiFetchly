{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Core MCP Server and Automatic Startup",
        "description": "Set up the basic MCP server using the '@modelcontextprotocol/sdk' and integrate it into the aiFetchly Electron application. The server must start automatically as a child process when the main application launches.",
        "details": "This task involves creating the core `AiFetchlyMCPServer` class, using `StdioServerTransport` for communication, and implementing the `MCPIntegration` class within the Electron main process to spawn and manage the server lifecycle. The build process must be configured to compile the MCP server code separately (e.g., using `tsconfig.mcp-server.json`).",
        "testStrategy": "Verify the MCP server process starts within 5 seconds of the Electron app launch by checking process lists and application logs. Use a simple MCP client to send a basic request (e.g., for system status) and confirm a valid response is received.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Separate Build Process for MCP Server",
            "description": "Set up the necessary build configuration to compile the MCP server TypeScript code into a separate JavaScript executable script.",
            "dependencies": [],
            "details": "Create a `tsconfig.mcp-server.json` file that extends the base tsconfig. Update the build scripts in `package.json` to add a new command that uses this configuration to compile the server source files into the application's distribution directory.",
            "status": "done",
            "testStrategy": "Run the new build command and verify that the compiled server JavaScript file is created in the expected output directory without errors."
          },
          {
            "id": 2,
            "title": "Implement Core AiFetchlyMCPServer Class",
            "description": "Create the main server class using the '@modelcontextprotocol/sdk' that initializes the server and listens for requests via standard I/O.",
            "dependencies": [],
            "details": "Define the `AiFetchlyMCPServer` class. In its main execution block, instantiate the `MCPServer` from the SDK, configuring it to use `StdioServerTransport`. This class will be the entry point for the child process.",
            "status": "done",
            "testStrategy": "Execute the compiled server script directly from the command line. Verify it runs without crashing and waits for input, indicating the transport layer is active."
          },
          {
            "id": 3,
            "title": "Implement MCPIntegration Class to Spawn Server Process",
            "description": "Develop the `MCPIntegration` class within the Electron main process to handle the spawning and management of the MCP server child process.",
            "dependencies": [],
            "details": "Create the `MCPIntegration` class. Implement a `startServer` method that uses Node.js's `child_process.spawn` to execute the compiled MCP server script. The method should capture the child process's `stdout`, `stderr`, and `exit` events for logging.",
            "status": "done",
            "testStrategy": "Instantiate and call `startServer` from a test script. Verify that the MCP server process appears in the system's process list."
          },
          {
            "id": 4,
            "title": "Integrate Automatic Server Startup on App Launch",
            "description": "Integrate the `MCPIntegration` class into the Electron application's startup sequence to ensure the server starts automatically when the app launches.",
            "dependencies": [],
            "details": "In the main Electron entry file (e.g., `main.ts`), import and instantiate the `MCPIntegration` class. After the Electron `app` emits the 'ready' event, call the `startServer` method. Implement logic to gracefully terminate the server process when the application quits.",
            "status": "done",
            "testStrategy": "Launch the full Electron application. Check application logs and the system process list to confirm the MCP server process starts automatically within 5 seconds of launch."
          },
          {
            "id": 5,
            "title": "Establish and Verify Basic IPC Communication",
            "description": "Implement a basic client-side request to confirm that the Electron main process can successfully communicate with the spawned MCP server over stdio.",
            "dependencies": [],
            "details": "Add a placeholder tool (e.g., `get_server_status`) to the `AiFetchlyMCPServer`. In the `MCPIntegration` class, create a method to send a JSON-RPC request for this tool to the child process's `stdin` and listen for a response on its `stdout`.",
            "status": "done",
            "testStrategy": "After the server starts, trigger the test request. Verify that the main process logs show a valid success response received from the MCP server, confirming the end-to-end communication channel is working."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Login State Monitoring and IPC Communication",
        "description": "Develop the mechanism for the main aiFetchly application to monitor its login state and communicate any changes to the MCP server child process via Inter-Process Communication (IPC).",
        "details": "Create a `LoginStateMonitor` in the Electron main process. The `MCPIntegration` class will use IPC (e.g., writing to the child process's stdin) to send JSON messages about login state changes. The MCP server must listen for these messages, update its internal state, and implement a `validateLoginState` check to be called before executing any tool.",
        "testStrategy": "Manually log in and out of the aiFetchly app and verify the MCP server logs the state change. Attempt to call a protected tool while logged out and confirm the correct `USER_NOT_LOGGED_IN` error response is returned as per the PRD specification.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LoginStateMonitor in Electron Main Process",
            "description": "Implement the `LoginStateMonitor` class in the main Electron process to detect and emit events for user login and logout actions.",
            "dependencies": [],
            "details": "This class must hook into the existing aiFetchly authentication flow. When the user's login status changes, it should emit a 'loginStateChanged' event with the new state payload (e.g., { isLoggedIn: true, user: '...' }).",
            "status": "done",
            "testStrategy": "Manually log in and out of the application and use console logs in the main process to verify that the monitor emits the correct event and payload."
          },
          {
            "id": 2,
            "title": "Send Login State via IPC from MCPIntegration",
            "description": "Modify the `MCPIntegration` class to listen for state changes from the `LoginStateMonitor` and forward them to the MCP server child process via its standard input.",
            "dependencies": [
              "2.1"
            ],
            "details": "Subscribe to the 'loginStateChanged' event from the monitor. Upon receiving an event, serialize the state payload into a JSON string and write it to the child process's `stdin` stream, ensuring each message is terminated with a newline character.",
            "status": "done",
            "testStrategy": "Observe the main process logs to confirm that a JSON message is prepared and an attempt to write to the child process's stdin is made immediately after a login state change."
          },
          {
            "id": 3,
            "title": "Implement IPC Message Listener in MCP Server",
            "description": "Configure the MCP server to listen on its standard input (`stdin`) for incoming JSON messages from the main Electron process.",
            "dependencies": [],
            "details": "The `StdioServerTransport` or a dedicated handler within the `AiFetchlyMCPServer` must be configured to read data from `process.stdin`. It needs to handle data chunking, buffer incoming data until a newline delimiter is found, and then parse the complete line as a JSON object.",
            "status": "done",
            "testStrategy": "In a standalone test, run the MCP server and manually pipe a valid JSON string (e.g., '{\"isLoggedIn\":true}\\n') to its stdin. Verify the server logs that it has successfully parsed the object."
          },
          {
            "id": 4,
            "title": "Manage Internal Login State in MCP Server",
            "description": "Implement a state management mechanism within the MCP server to store and update the login status received via IPC.",
            "dependencies": [
              "2.3"
            ],
            "details": "Create a variable or a simple state object within the server's scope (e.g., in the server's context or a dedicated state module). This state should be updated whenever a valid login state message is parsed from stdin. The initial state must default to logged-out.",
            "status": "done",
            "testStrategy": "After the server parses an IPC message (as in the previous subtask's test), add a log to print the server's internal login state variable to confirm it has been updated correctly."
          },
          {
            "id": 5,
            "title": "Implement `validateLoginState` Pre-execution Check",
            "description": "Create a `validateLoginState` function that tool handlers can call to enforce authentication before executing their logic.",
            "dependencies": [
              "2.4"
            ],
            "details": "This function will check the internal login state managed in the previous subtask. If the state indicates the user is not logged in, the function must throw a specific error (e.g., `LoginStateError`) that the MCP framework can catch and translate into the `USER_NOT_LOGGED_IN` error response.",
            "status": "done",
            "testStrategy": "Create a dummy tool that calls this validator. Attempt to execute the tool via an MCP client while the server's state is 'logged-out' and confirm the client receives the specified `USER_NOT_LOGGED_IN` error JSON."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop MCP Tools for Search Engine Scraping",
        "description": "Create and register MCP tools for scraping search engines like Google and Bing, integrating with the existing `SearchEngineController` or equivalent business logic.",
        "details": "Define the Zod schemas for `search_google` and `search_bing` tools as specified in the PRD. The tool's handler function will first call `validateLoginState`, then delegate the scraping logic to the existing `aiFetchlyController`, and finally format the output to match the `MCPGoogleSearchResponse` interface.",
        "testStrategy": "Execute the `search_google` tool via an MCP client with a test query. Verify the response format matches the specification and that the data (titles, URLs, descriptions) is accurate. Test with optional parameters like `pages` and `language`.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Zod Schemas for Search Tools",
            "description": "Create and export the Zod schemas for the `search_google` and `search_bing` tool input parameters. These schemas must align with the specifications in the PRD, defining fields like `query`, `pages`, and `language` with appropriate types and validation.",
            "dependencies": [],
            "details": "The schemas will serve as the single source of truth for validating inputs to the search engine tools. Ensure they are defined in a shared location accessible by the tool definition files.",
            "status": "done",
            "testStrategy": "Write unit tests to validate that the schemas correctly accept valid input objects and reject objects with missing or malformed data."
          },
          {
            "id": 2,
            "title": "Implement a Standardized Response Formatter",
            "description": "Develop a dedicated utility function that takes the raw output from the `aiFetchlyController` and transforms it into the strict `MCPGoogleSearchResponse` interface format. This ensures consistent output structure for all search engine tools.",
            "dependencies": [],
            "details": "The function should handle mapping fields, cleaning up data, and ensuring all required properties of the `MCPGoogleSearchResponse` interface are present. It should gracefully handle cases where the controller returns partial or empty data.",
            "status": "done",
            "testStrategy": "Unit test the formatter with mock data from the `aiFetchlyController` to verify it produces a correctly structured `MCPGoogleSearchResponse`."
          },
          {
            "id": 3,
            "title": "Implement the `search_google` Tool Handler",
            "description": "Create the handler function for the `search_google` tool. The handler must first call `validateLoginState`, then delegate the scraping logic to the `aiFetchlyController` with Google-specific parameters, and finally use the standardized formatter to shape the response.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "The handler will receive the validated input from the Zod schema. It will be responsible for orchestrating the call flow and handling any errors from the controller or validation steps.",
            "status": "done",
            "testStrategy": "Execute the handler directly with test data and mock the `aiFetchlyController` and `validateLoginState` functions to verify the logic flow and response formatting."
          },
          {
            "id": 4,
            "title": "Implement the `search_bing` Tool Handler",
            "description": "Create the handler function for the `search_bing` tool, mirroring the structure of the Google handler. It will call `validateLoginState`, delegate to the `aiFetchlyController` with Bing-specific parameters, and use the same standardized formatter for the response.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "This implementation should reuse as much logic as possible from the `search_google` handler, primarily changing the parameters passed to the `aiFetchlyController` to target the Bing search engine.",
            "status": "done",
            "testStrategy": "Similar to the Google handler, execute this handler with test data and mocks to ensure it correctly calls the controller for Bing and formats the output."
          },
          {
            "id": 5,
            "title": "Register Search Tools with MCP Server",
            "description": "Combine the Zod schemas and their corresponding handler functions to create the complete `search_google` and `search_bing` tool objects. Register these new tools with the MCP server's tool registry to make them available to the MCP client.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "This final step involves updating the main tool registry file, importing the newly created tools, and adding them to the list of available MCP tools. This makes the functionality live on the server.",
            "status": "done",
            "testStrategy": "Start the MCP server and use an MCP client to call the `search_google` tool with a test query. Verify a successful response is received and its format matches the `MCPGoogleSearchResponse` specification."
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop MCP Tools for Yellow Pages Scraping",
        "description": "Integrate the existing yellow pages scraping functionality into the MCP server by creating tools such as `scrape_yellow_pages` and `get_business_details`.",
        "details": "Define Zod schemas for the yellow pages tools based on the PRD. The implementation will act as an adapter, calling methods on the existing `YellowPagesController`, and formatting the results into the specified `MCPYellowPagesResponse` format.",
        "testStrategy": "Call the `scrape_yellow_pages` tool with parameters for platform (e.g., 'yelp.com'), search term, and location. Validate the structure and content of the returned business data against the `YellowPagesResult` interface.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zod Schemas for Yellow Pages Tools",
            "description": "Define Zod schemas for the yellow pages MCP tools including scrape_yellow_pages and get_business_details with proper validation for parameters like platform, query, location, and maxResults.",
            "details": "Create schemas that validate the MCPYellowPagesRequest interface parameters including platform (yelp, yellowpages, google_business), query string, location, maxResults, radius, and sortBy options.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "Implement Yellow Pages Response Formatter",
            "description": "Create a utility function to format the raw output from YellowPagesController into the standardized MCPYellowPagesResponse format.",
            "details": "Develop a formatter that converts YellowPagesController results to MCPBusinessListing format, ensuring consistent response structure with proper field mapping and data validation.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "Implement scrape_yellow_pages Tool Handler",
            "description": "Create the MCP tool handler for scrape_yellow_pages that validates login state, calls YellowPagesController, and formats the response.",
            "details": "Implement a handler that calls validateLoginState, delegates to YellowPagesController.handleMCPRequest, and uses the response formatter to return properly structured MCPYellowPagesData.",
            "status": "done",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "Implement get_business_details Tool Handler",
            "description": "Create the MCP tool handler for get_business_details that retrieves detailed information about a specific business listing.",
            "details": "Implement a handler that takes a business ID or URL, validates login state, calls YellowPagesController to get detailed business information, and formats the response as MCPBusinessListing.",
            "status": "done",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "parentTaskId": 4
          },
          {
            "id": 5,
            "title": "Register Yellow Pages Tools with MCP Server",
            "description": "Register the yellow pages tools with the MCP server's tool registry to make them available to MCP clients.",
            "details": "Combine the Zod schemas and handler functions to create complete tool objects for scrape_yellow_pages and get_business_details, then register them with the MCP server.",
            "status": "done",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop MCP Tools for Website Email Extraction",
        "description": "Create MCP tools for extracting email addresses from a list of websites, including `extract_emails_from_website` and `validate_email_list`.",
        "details": "Implement the tool logic, which will leverage the existing `BrowserManager` and `EmailExtractionController`. Define the Zod schemas for the tool parameters. Ensure the response format strictly matches the `MCPEmailExtractionResponse` and `MCPEmailValidationResponse` specifications.",
        "testStrategy": "Provide a list of test URLs to `extract_emails_from_website` and verify that the tool correctly crawls the sites, extracts emails, and returns them in the specified format. Test the `validate_email_list` tool with a mix of valid, invalid, and disposable emails to check accuracy.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zod Schemas for Email Extraction Tools",
            "description": "Define Zod schemas for the email extraction MCP tools including extract_emails_from_website and validate_email_list with proper validation for parameters like websites, maxDepth, and email validation options.",
            "details": "Create schemas that validate the MCPEmailExtractionRequest interface parameters including websites array, maxDepth, includeSubdomains, excludePatterns, and timeout options. Also create schemas for email validation parameters.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Implement Email Extraction Response Formatter",
            "description": "Create a utility function to format the raw output from EmailExtractionController into the standardized MCPEmailExtractionResponse format.",
            "details": "Develop a formatter that converts EmailExtractionController results to MCPExtractedEmail format, ensuring consistent response structure with proper field mapping and data validation.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "Implement extract_emails_from_website Tool Handler",
            "description": "Create the MCP tool handler for extract_emails_from_website that validates login state, calls EmailExtractionController, and formats the response.",
            "details": "Implement a handler that calls validateLoginState, delegates to EmailExtractionController.handleMCPRequest, and uses the response formatter to return properly structured MCPEmailExtractionData.",
            "status": "done",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "Implement validate_email_list Tool Handler",
            "description": "Create the MCP tool handler for validate_email_list that validates a list of email addresses for validity and checks against disposable email services.",
            "details": "Implement a handler that takes a list of email addresses, validates their format, checks against known disposable email services, and returns validation results with confidence scores.",
            "status": "done",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "Register Email Extraction Tools with MCP Server",
            "description": "Register the email extraction tools with the MCP server's tool registry to make them available to MCP clients.",
            "details": "Combine the Zod schemas and handler functions to create complete tool objects for extract_emails_from_website and validate_email_list, then register them with the MCP server.",
            "status": "done",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop MCP Tools for Email Marketing Task Management",
        "description": "Implement a set of MCP tools for managing email marketing tasks, providing full CRUD (Create, Read, Update, Delete) functionality.",
        "details": "Create tools: `create_email_task`, `get_email_task`, `update_email_task`, and `delete_email_task`. These tools will interface with the existing `EmailMarketingController` and the corresponding database models for tasks.",
        "testStrategy": "Perform a full CRUD lifecycle test: 1. Create a task. 2. Retrieve it to verify creation. 3. Update its name/status. 4. Retrieve it again to verify the update. 5. Delete the task and confirm it's no longer retrievable.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zod Schemas for Email Marketing Task Tools",
            "description": "Define Zod schemas for the email marketing task MCP tools including create_email_task, get_email_task, update_email_task, and delete_email_task with proper validation for task parameters.",
            "details": "Create schemas that validate email marketing task parameters including task name, description, status, priority, scheduledAt, and other relevant fields for CRUD operations.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 2,
            "title": "Implement Email Marketing Task Response Formatter",
            "description": "Create a utility function to format the raw output from EmailMarketingController into standardized MCP response formats.",
            "details": "Develop a formatter that converts EmailMarketingController results to MCPTask format, ensuring consistent response structure with proper field mapping and data validation.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 3,
            "title": "Implement CRUD Tool Handlers for Email Marketing Tasks",
            "description": "Create MCP tool handlers for create_email_task, get_email_task, update_email_task, and delete_email_task that validate login state and call EmailMarketingController.",
            "details": "Implement handlers that call validateLoginState, delegate to EmailMarketingController.handleMCPRequest for each CRUD operation, and use the response formatter to return properly structured MCPTask data.",
            "status": "done",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "parentTaskId": 6
          },
          {
            "id": 4,
            "title": "Register Email Marketing Task Tools with MCP Server",
            "description": "Register the email marketing task tools with the MCP server's tool registry to make them available to MCP clients.",
            "details": "Combine the Zod schemas and handler functions to create complete tool objects for all CRUD operations, then register them with the MCP server.",
            "status": "done",
            "dependencies": [
              "6.3"
            ],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop General Task and Resource Management Tools",
        "description": "Create high-level tools for managing scraping tasks (`create_scraping_task`, `get_task_status`) and monitoring system health (`get_system_status`).",
        "details": "The `create_scraping_task` tool will be a generic wrapper for creating different types of tasks. The `get_system_status` tool will aggregate data from the `LoginStateMonitor` and other system metrics to provide a health overview as defined in the `MCPSystemStatusResponse` format.",
        "testStrategy": "Call `get_system_status` and verify all fields are populated correctly (uptime, browser instances, etc.). Create a task using `create_scraping_task` and then poll its status with `get_task_status` to check for progress updates.",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Authentication Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials and session data.",
            "dependencies": [],
            "details": "Create a `users` table with columns like `id`, `username`, `email`, `password_hash`, `created_at`, and `updated_at`. The `password_hash` column must store a securely hashed password (e.g., using bcrypt or Argon2), not plaintext. Use a database migration tool to manage schema changes.",
            "status": "done",
            "testStrategy": "Write unit tests for the data models. Manually inspect the database schema after running migrations to ensure it matches the design. Verify constraints like `UNIQUE` on email/username."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint must accept user details (e.g., username, email, password). It must validate the input, checking for existing usernames/emails and enforcing password complexity rules. Securely hash the password before storing it in the database. Return a success message or appropriate error codes (e.g., 201 Created, 400 Bad Request, 409 Conflict).",
            "status": "done",
            "testStrategy": "Write integration tests simulating POST requests. Test success cases with valid data, and failure cases like duplicate emails, weak passwords, and missing fields. Verify that the user is correctly created in the database with a properly hashed password."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a session token.",
            "dependencies": [],
            "details": "The endpoint should accept user credentials (e.g., email and password). Retrieve the user from the database and compare the provided password with the stored hash. If successful, generate and return a session token (e.g., a JSON Web Token - JWT) with an appropriate expiration time. If unsuccessful, return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Write integration tests for the login endpoint. Test with valid credentials to ensure a valid JWT is returned. Test with invalid credentials (wrong password, non-existent user) to ensure a 401 error is returned."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create middleware to verify the session token on incoming requests to protected API endpoints, denying access to unauthenticated users.",
            "dependencies": [],
            "details": "The middleware should extract the token from the request headers (e.g., `Authorization: Bearer <token>`). It must validate the token's signature and check for expiration. If the token is valid, attach the authenticated user's information to the request object for use by subsequent handlers. If the token is invalid or missing, return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Create a dummy protected endpoint. Write integration tests that call this endpoint with a valid token, an invalid/malformed token, an expired token, and no token. Verify that the correct HTTP status code (e.g., 200 OK or 401 Unauthorized) is returned in each case."
          },
          {
            "id": 5,
            "title": "Develop User Logout API Endpoint",
            "description": "Create an API endpoint (e.g., POST /api/auth/logout) to invalidate the user's current session.",
            "dependencies": [],
            "details": "The implementation depends on the session strategy. For stateless JWTs, implement a server-side token blocklist (e.g., in Redis) to store invalidated tokens until they expire. The endpoint will add the current token's ID to this list. The authentication middleware must be updated to check this blocklist.",
            "status": "done",
            "testStrategy": "Write an integration test: 1. Log in a user to get a token. 2. Call the logout endpoint with that token. 3. Attempt to use the same token to access a protected route and verify that access is denied with a 401 Unauthorized error."
          }
        ]
      },
      {
        "id": 8,
        "title": "Refactor Existing Controllers for Seamless MCP Integration",
        "description": "Adapt existing controllers (e.g., `SearchController`, `EmailController`) to handle requests originating from the MCP server, ensuring they can process parameters and return data in a consistent, MCP-compatible format.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "This is a cross-cutting task. It involves creating `handleMCPRequest` adapter methods in the existing controllers. This ensures a clean separation of concerns, where the MCP tool implementation is a thin layer that calls into the core business logic without duplicating it.",
        "testStrategy": "Write unit tests for each controller's adapter method, mocking MCP-style input and asserting that the correct underlying business logic is invoked. Integration tests are covered by the individual tool tests (Tasks 3-7).",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for MCP Requests and Responses",
            "description": "Create and standardize TypeScript interfaces (e.g., `MCPRequest`, `MCPSuccessResponse`, `MCPErrorResponse`) to ensure type safety and consistency for data exchanged between the MCP server and the refactored controllers.",
            "status": "done",
            "dependencies": [],
            "details": "These interfaces will define the structure for tool parameters, success payloads, and standardized error objects. Place them in a shared types directory.\n<info added on 2025-09-08T13:56:11.450Z>\nThe comprehensive MCP type definitions have been implemented in `src/mcp-server/types/mcpTypes.ts`. This file establishes the foundational types for all MCP interactions, including:\n- Base request/response interfaces and associated Zod schemas for runtime validation.\n- Specific types for all major functionality areas (search, email extraction, yellow pages, task management, system status, user management).\n- A standardized error handling structure with defined error codes.\n- Utility functions for creating consistent success and error responses.\n- Pagination support for list operations.\n</info added on 2025-09-08T13:56:11.450Z>",
            "testStrategy": "Code review and static analysis to ensure interfaces are comprehensive and correctly applied in subsequent subtasks."
          },
          {
            "id": 2,
            "title": "Implement `handleMCPRequest` for Search and Email Extraction Controllers",
            "description": "Refactor `SearchController` and `EmailextractionController` to include an `handleMCPRequest` adapter method. This method will translate MCP-style parameters into calls to the existing business logic.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "The adapter will handle parameter mapping, invoke the core search/extraction functions, and format the results and any errors into the standard MCP response format defined in the new interfaces.\n<info added on 2025-09-08T14:03:16.216Z>\n`handleMCPRequest` methods have been successfully implemented for both `SearchController` and `EmailextractionController`.\n\n**SearchController:**\n- An MCP adapter method has been added to handle 9 different tool types (search_google, search_bing, create_search_task, list_search_tasks, get_search_task, update_search_task, get_search_results, retry_search_task, get_task_error_log, get_task_details_for_edit).\n- Implemented parameter mapping between the MCP format and internal controller methods, along with helper methods for engine ID mapping and task status conversion.\n\n**EmailextractionController:**\n- An MCP adapter method has been added to handle 9 different tool types (extract_emails_from_website, create_email_extraction_task, list_email_extraction_tasks, get_email_extraction_task, update_email_extraction_task, delete_email_extraction_task, get_email_extraction_results, get_email_task_error_log, get_email_task_count).\n- Implemented parameter mapping and helper methods for task status conversion.\n\nBoth adapters provide a clean interface between MCP requests and the existing business logic, ensuring standardized MCP responses with proper error handling and type safety.\n</info added on 2025-09-08T14:03:16.216Z>",
            "testStrategy": "Write unit tests for `handleMCPRequest` in both controllers, mocking MCP input and asserting that the correct underlying service methods are called with the right arguments and the response is correctly formatted."
          },
          {
            "id": 3,
            "title": "Implement `handleMCPRequest` for YellowPagesController",
            "description": "Adapt the `YellowPagesController` by adding an `handleMCPRequest` method to process MCP tool requests for yellow pages scraping.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "This method will parse MCP parameters (e.g., platform, search term, location), call the existing scraping logic, and return the data or errors in the MCP-compatible format.\n<info added on 2025-09-08T14:09:34.440Z>\nThe `handleMCPRequest` adapter method has been implemented, supporting 17 different tool types. This includes `scrape_yellow_pages` as well as a full suite for task management (e.g., `create_yellow_pages_task`, `list_yellow_pages_tasks`, `get_yellow_pages_task_progress`), data export, and status checks (`get_yellow_pages_health_status`, `get_yellow_pages_statistics`). The implementation involved creating proper parameter mapping from the MCP format to internal methods, adding helper functions to convert internal `TaskStatus` enums to MCP status strings, and updating the `MCPBusinessListing` interface to be more flexible. The new adapter provides a clean, type-safe interface to the core business logic, ensuring standardized MCP responses and error handling.\n</info added on 2025-09-08T14:09:34.440Z>",
            "testStrategy": "Unit test the adapter method by providing mock MCP requests for Yelp/other platforms and verifying the response structure and the delegation to the correct internal scraping functions."
          },
          {
            "id": 4,
            "title": "Implement `handleMCPRequest` for TaskController",
            "description": "Refactor the `TaskController` to add an `handleMCPRequest` adapter for handling CRUD operations on tasks originating from MCP tools.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "The adapter will differentiate between create, read, update, and delete operations based on the MCP request parameters, call the corresponding business logic, and format the response.",
            "testStrategy": "Create unit tests for each CRUD action via the `handleMCPRequest` method. For example, test creating a task and assert the response format. Mock database interactions."
          },
          {
            "id": 5,
            "title": "Implement `handleMCPRequest` for User and SystemSetting Controllers",
            "description": "Add `handleMCPRequest` adapter methods to the `UserController` and `SystemSettingController` to manage user/system settings via MCP.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "These adapters will process requests for fetching or updating settings, call the relevant service methods, and ensure the response conforms to the MCP standard.",
            "testStrategy": "Write unit tests for the adapter methods, simulating MCP requests to get/set settings and asserting the correct logic is invoked and the response is properly structured."
          },
          {
            "id": 6,
            "title": "Update AiFetchlyController to Delegate to New Adapters",
            "description": "Modify the `AiFetchlyController`, which acts as the central entry point for MCP tools, to use the new `handleMCPRequest` methods on the respective controllers instead of calling their business logic methods directly.",
            "status": "done",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "This change centralizes the MCP interaction logic within each controller, simplifying the `AiFetchlyController` and adhering to the separation of concerns principle. The controller will now act as a router, passing the MCP request to the appropriate controller's adapter.",
            "testStrategy": "Integration tests for this are covered by the individual tool tests (Tasks 3-7). Manually review the `AiFetchlyController` to ensure all direct calls are replaced with calls to `handleMCPRequest`."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Robust Error Handling and Server Recovery",
        "description": "Enhance the MCP server and its integration with robust error handling, including standardized error responses and an automatic restart mechanism for the server process.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "Implement the `LoginStateError` response format for authentication and application state failures. In the `MCPIntegration` class, add logic to monitor the child process and automatically restart it with a delay if it exits with a non-zero code. Implement retry logic for the initial server startup.",
        "testStrategy": "Test error paths by calling a tool when logged out to verify the error JSON. Manually kill the MCP server process (`kill -9`) and confirm that the main Electron app automatically restarts it after a short delay.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `LoginStateError` Response Format",
            "description": "Define and implement a standardized JSON error structure for authentication and application state failures, as per the `LoginStateError` specification.",
            "status": "done",
            "dependencies": [],
            "details": "Create a standardized error class or factory function in the MCP server that generates a consistent JSON response for authentication errors. This response should include a unique error code (e.g., 'AUTH_REQUIRED'), a human-readable message, and a type field. This will be used when `validateLoginState` fails.",
            "testStrategy": "Write a unit test to verify that calling a protected function without the required state produces the exact `LoginStateError` JSON format. Manually test by logging out of the app and calling a tool, confirming the error is received by the client."
          },
          {
            "id": 2,
            "title": "Implement Retry Logic for Initial Server Startup",
            "description": "Add a retry mechanism with backoff to the `MCPIntegration` class for cases where the MCP server fails to start on the initial attempt.",
            "status": "done",
            "dependencies": [],
            "details": "In the `MCPIntegration` class, wrap the server spawning logic in a function that can be retried. If the child process fails to start or exits with an error code immediately, implement a retry loop (e.g., 3 attempts) with an exponential backoff delay (e.g., 2s, 4s, 8s) to handle transient startup issues.",
            "testStrategy": "Introduce a temporary bug in the MCP server's startup code to make it crash. Launch the Electron app and monitor the logs to confirm that it attempts to restart the server multiple times with increasing delays before failing permanently."
          },
          {
            "id": 3,
            "title": "Add MCP Server Process Monitoring and Auto-Restart",
            "description": "Implement logic in the `MCPIntegration` class to monitor the health of the MCP server child process and automatically restart it if it crashes unexpectedly.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Attach an 'exit' event listener to the spawned child process. If the process exits with a non-zero code after it has been running successfully, log the crash and initiate a restart sequence. Use a fixed delay (e.g., 5 seconds) to avoid a tight restart loop.",
            "testStrategy": "Once the server is running, find its process ID and terminate it forcefully (`kill -9 <pid>`). Verify that the main Electron application detects the termination and automatically relaunches the MCP server process after the configured delay."
          },
          {
            "id": 4,
            "title": "Enhance General Error Handling in `MCPIntegration`",
            "description": "Improve the error handling within the `MCPIntegration` class to gracefully manage communication errors and other unexpected issues between the main app and the server.",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Add `try...catch` blocks around IPC communication points (e.g., writing to stdin). Handle potential errors like a closed pipe if the server crashes during a write. Ensure that errors from the child process's stderr are captured, logged, and potentially surfaced to the user or a developer console.",
            "testStrategy": "Write unit tests for the `MCPIntegration` class, mocking the child process to simulate errors like a write failure or receiving an error on stderr. Verify that these errors are caught and logged appropriately without crashing the main application."
          },
          {
            "id": 5,
            "title": "Implement Comprehensive Error Logging",
            "description": "Integrate a structured logging mechanism for all error-related events, including server crashes, restart attempts, and standardized error responses.",
            "status": "done",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use a logging library (e.g., Winston, Pino) in both the Electron main process and the MCP server. Log all server start/stop/crash/restart events with timestamps and context. Log all generated `LoginStateError` responses and any caught exceptions in the `MCPIntegration` class to a dedicated log file for easier debugging.",
            "testStrategy": "Perform all test strategies from the other subtasks (e.g., kill process, simulate startup failure). After the tests, inspect the log files to ensure all events were logged correctly with appropriate severity levels (e.g., INFO for startup, ERROR for crash, WARN for restart attempt)."
          }
        ]
      },
      {
        "id": 10,
        "title": "Finalize Security, Performance, and Compliance Measures",
        "description": "Finalize the implementation by adding rate limiting, comprehensive logging, and ensuring compliance with web scraping ethics and email marketing regulations.",
        "details": "Implement respectful rate limiting for all scraping platforms. Add audit logging for all MCP tool calls to a new `MCPRequestLog` table. Review all scraping logic to ensure it respects `robots.txt` and uses appropriate user agents. Ensure email tools include required compliance features like unsubscribe links.",
        "testStrategy": "Conduct load testing to ensure the server meets the sub-500ms response time and 50+ concurrent connections target. Perform a security review of the code. Verify that firing rapid requests to a tool triggers a rate-limiting error.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rate Limiting for MCP Tools",
            "description": "Add rate limiting to all MCP tools to prevent abuse and ensure fair usage across all scraping platforms.",
            "details": "Implement rate limiting middleware that tracks requests per user/IP and enforces limits (e.g., 100 requests per minute per user). Use Redis or in-memory store for tracking. Apply different limits for different tool types based on their resource intensity.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 2,
            "title": "Add Comprehensive Audit Logging",
            "description": "Implement audit logging for all MCP tool calls to track usage, errors, and security events.",
            "details": "Create MCPRequestLog table and logging system that records all tool calls with timestamps, user info, parameters (sanitized), responses, and performance metrics. Include security events like failed authentication attempts.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 3,
            "title": "Implement Web Scraping Ethics Compliance",
            "description": "Ensure all scraping logic respects robots.txt, uses appropriate user agents, and follows ethical scraping practices.",
            "details": "Review and update all scraping controllers to check robots.txt before scraping, use respectful user agents, implement proper delays between requests, and respect rate limits set by target websites.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 4,
            "title": "Add Email Marketing Compliance Features",
            "description": "Ensure email marketing tools include required compliance features like unsubscribe links and opt-out mechanisms.",
            "details": "Update email marketing tools to include unsubscribe links, opt-out mechanisms, and compliance with CAN-SPAM Act and GDPR requirements. Add validation for required compliance fields.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 5,
            "title": "Performance Optimization and Load Testing",
            "description": "Optimize server performance and conduct load testing to ensure sub-500ms response times and 50+ concurrent connections.",
            "details": "Review and optimize database queries, implement caching where appropriate, optimize response formatting, and conduct comprehensive load testing to verify performance targets are met.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 10
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-08T07:14:03.838Z",
      "updated": "2025-09-08T15:18:00.386Z",
      "description": "Tasks for master context"
    }
  }
}